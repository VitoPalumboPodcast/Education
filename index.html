<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<title>Generatore Mappe Mentali Avanzato</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); margin: 0; height: 100vh; overflow: hidden; }
.toolbar { position:fixed;top:0;left:0;right:0;background:rgba(255,255,255,0.95);backdrop-filter:blur(10px);padding:12px;z-index:100;display:flex;flex-wrap:wrap;gap:8px;align-items:center;border-bottom:1px solid rgba(0,0,0,0.1);box-shadow:0 2px 20px rgba(0,0,0,0.1); transition:top .25s; }
.toolbar.hide { top: -100px; /* Adjusted for potentially taller toolbar on mobile */ }
.btn { background:#3498db;color:#fff;border:none;border-radius:8px;padding:8px 16px;font-size:14px;cursor:pointer;display:flex;align-items:center;gap:6px;transition:all .2s;font-weight:500;box-shadow:0 2px 8px rgba(52,152,219,0.3);}
.btn:hover { background:#217dbb;transform:translateY(-1px);box-shadow:0 4px 12px rgba(52,152,219,0.4);}
.btn:disabled { background:#bdc3c7; cursor:not-allowed; box-shadow: none; transform: none;}
.btn.danger {background:#e74c3c;box-shadow:0 2px 8px rgba(231,76,60,0.3);}
.btn.danger:hover {background:#c0392b;}
.btn.secondary {background:#6c757d;box-shadow:0 2px 8px rgba(108,117,125,0.3);}
.btn.secondary:hover {background:#5a6268;}
.btn.success {background:#27ae60;box-shadow:0 2px 8px rgba(39,174,96,0.3);}
.btn.success:hover {background:#219a52;}
.btn.active { box-shadow:0 2px 12px rgba(52,152,219,0.6);transform:scale(1.05);}
.btn-group { display:flex; gap:4px; margin-right:8px; }
.divider { width:1px; height:30px; background:rgba(0,0,0,0.1); margin:0 8px; }
#mindmap-container { width:100vw; height:calc(100vh - 75px); margin-top:75px; position:relative; background:radial-gradient(circle at center, rgba(255,255,255,0.9) 0%, rgba(240,248,255,0.95) 100%); border-radius:12px 12px 0 0; box-shadow:inset 0 1px 3px rgba(0,0,0,0.1); }
#mindmap-svg { width:100%; height:100%; border-radius:12px 12px 0 0; }
.node { transition: opacity 0.3s; }
.node.dimmed { opacity: 0.3; }
.node.selected > :first-child { filter: drop-shadow(3px 3px 12px rgba(52,152,219,0.6));} /* Apply shadow to shape */
.node-text { user-select:none; pointer-events:none; font-weight:500; }
.node-icon { pointer-events:none; }
.connection { stroke:#34495e; stroke-width:2.5; transition: stroke 0.2s, stroke-width 0.2s; }
.connection.selected { stroke:#3498db; stroke-width:3.5; }
.connection-label { font-size:12px; fill:#2c3e50; font-weight:500; user-select:none; pointer-events:none; }
.sidebar { position:fixed;right:-380px;top:75px;width:380px;height:calc(100vh - 75px);background:rgba(255,255,255,0.98);backdrop-filter:blur(15px);box-shadow:-4px 0 20px rgba(0,0,0,0.15);transition:right .35s;z-index:200;padding:20px;overflow-y:auto;border-radius:12px 0 0 0;}
.sidebar.open {right:0;}
.form-group{margin-bottom:18px;}
.form-group label{font-weight:600;margin-bottom:6px;display:block;color:#2c3e50;}
.form-group input[type=text], .form-group textarea, .form-group select, .form-group input[type=range]{width:100%;padding:10px;font-size:14px;border:2px solid #e9ecef;border-radius:8px;transition:border-color .2s;box-sizing: border-box;}
.form-group input[type=range]{padding:0;}
.form-group input:focus, .form-group textarea:focus, .form-group select:focus{outline:none;border-color:#3498db;box-shadow:0 0 0 3px rgba(52,152,219,0.1);}
.color-picker{display:flex;gap:8px;flex-wrap:wrap;}
.color-option{width:32px;height:32px;border-radius:8px;border:3px solid #fff;cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,0.15);transition:transform .2s;}
.color-option:hover{transform:scale(1.1);}
.color-option.selected{border-color:#3498db;transform:scale(1.15);}
.icon-picker{display:grid;grid-template-columns:repeat(auto-fill, minmax(40px, 1fr));gap:8px;}
.icon-option{width:100%;height:40px;display:flex;align-items:center;justify-content:center;border:2px solid #e9ecef;border-radius:8px;font-size:18px;cursor:pointer;transition:all .2s;}
.icon-option:hover{border-color:#3498db;background:#f8f9fa;}
.icon-option.selected{background:#3498db;color:white;border-color:#3498db;transform:scale(1.05);}
.loading{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(255,255,255,0.98);backdrop-filter:blur(10px);padding:30px;border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,0.2);z-index:400;display:none;align-items:center;gap:15px;}
.loading.show{display:flex;}
.spinner{width:32px;height:32px;border:3px solid #e9ecef;border-top-color:#3498db;border-radius:50%;animation:spin 1s linear infinite;}
@keyframes spin{to{transform:rotate(360deg);}}
.overlay-desc {position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:900;display:none;align-items:center;justify-content:center;background:rgba(20,34,50,0.8);backdrop-filter:blur(5px);}
.overlay-desc .overlay-desc-box{background:rgba(255,255,255,0.98);backdrop-filter:blur(15px);box-shadow:0 20px 60px rgba(0,0,0,0.3);border-radius:16px;padding:40px;min-width:300px;max-width:600px;text-align:left;animation:slideIn 0.3s ease-out;}
.overlay-desc .overlay-desc-box h3{margin-top:0;font-size:1.5em;color:#2c3e50;border-bottom:2px solid #3498db;padding-bottom:10px;}
.overlay-desc .overlay-desc-box div {max-height: 70vh; overflow-y: auto; margin-top:10px;}
@keyframes slideIn{from{opacity:0;transform:translateY(-20px);}to{opacity:1;transform:translateY(0);}}
#json-modal { position:fixed;top:0;left:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.7);backdrop-filter:blur(5px);z-index:500; }
#json-modal-box { background:rgba(255,255,255,0.98);backdrop-filter:blur(15px);border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,0.3);padding:30px;max-width:90vw;max-height:85vh; display:flex; flex-direction:column; }
#json-area { width: 500px; max-width:85vw; height: 300px; font-family:'Courier New',monospace; font-size:13px; margin-bottom:15px;border:2px solid #e9ecef;border-radius:8px;padding:15px; flex-grow:1;}
.search-container { position:relative; margin-bottom:15px; }
.search-input { width:100%; padding:12px 40px 12px 15px; border:2px solid #e9ecef; border-radius:25px; font-size:14px; background:rgba(255,255,255,0.9);box-sizing: border-box; }
.search-icon { position:absolute; right:15px; top:50%; transform:translateY(-50%); color:#6c757d; }
.minimap { position:fixed; bottom:20px; right:20px; width:200px; height:120px; background:rgba(255,255,255,0.9); border:2px solid #3498db; border-radius:8px; z-index:150; overflow:hidden; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
.minimap svg { width:100%; height:100%; }
.minimap-viewport { fill:rgba(52,152,219,0.2); stroke:#3498db; stroke-width:1; pointer-events: all; cursor: move;}
.minimap .node-shape-mini { stroke: #555; stroke-width: 0.5; }
.minimap .connection-mini { stroke: #777; stroke-width: 0.5; }
.toast { position:fixed; top:90px; right:20px; background:#27ae60; color:white; padding:12px 20px; border-radius:8px; box-shadow:0 4px 15px rgba(0,0,0,0.2); z-index:1001; opacity:0; transform:translateX(100%); transition:opacity .3s, transform .3s; }
.toast.show { transform:translateX(0); opacity:1; }
.toast.error { background:#e74c3c; }
.shortcut-help { position:fixed; bottom:20px; left:20px; background:rgba(255,255,255,0.9); padding:15px; border-radius:8px; font-size:12px; color:#6c757d; max-width:250px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); z-index:150;}
.theme-toggle-icon .fa-sun { display: inline; }
.theme-toggle-icon .fa-moon { display: none; }
.dark-theme .theme-toggle-icon .fa-sun { display: none; }
.dark-theme .theme-toggle-icon .fa-moon { display: inline; }
.dark-theme { background: linear-gradient(135deg, #232526 0%, #414345 100%); }
.dark-theme #mindmap-container { background: radial-gradient(circle at center, rgba(40,40,45,0.95) 0%, rgba(30,30,35,0.98) 100%); }
.dark-theme .toolbar { background: rgba(35,37,38,0.95); border-bottom:1px solid rgba(255,255,255,0.1);box-shadow:0 2px 20px rgba(0,0,0,0.3);}
.dark-theme .sidebar { background: rgba(35,37,38,0.98); box-shadow:-4px 0 20px rgba(0,0,0,0.3); color:#f0f0f0;}
.dark-theme .form-group label { color:#f0f0f0; }
.dark-theme .form-group input, .dark-theme .form-group textarea, .dark-theme .form-group select { background:#2c3e50; border-color:#45484d; color:#f0f0f0; }
.dark-theme .form-group input:focus, .dark-theme .form-group textarea:focus, .dark-theme .form-group select:focus { border-color:#3498db; }
.dark-theme .search-input { background:rgba(44,62,80,0.9); color:#f0f0f0; border-color:#45484d; }
.dark-theme .search-icon { color:#aaa; }
.dark-theme .node-text { fill: #f0f0f0; } /* Default, overridden by node.textColor */
.dark-theme .connection { stroke:#bdc3c7; }
.dark-theme .connection.selected { stroke:#3498db; }
.dark-theme .connection-label { fill:#ecf0f1; }
.dark-theme #json-modal-box { background:rgba(35,37,38,0.98); }
.dark-theme #json-area { background:#2c3e50; color:#f0f0f0; border-color:#45484d; }
.dark-theme .minimap { background:rgba(44,62,80,0.9); border-color:#3498db; }
.dark-theme .minimap-viewport { stroke:#3498db; fill:rgba(52,152,219,0.3); }
.dark-theme .shortcut-help { background:rgba(44,62,80,0.9); color:#ccc; }
.dark-theme .overlay-desc .overlay-desc-box { background:rgba(35,37,38,0.98); }
.dark-theme .overlay-desc .overlay-desc-box h3 { color:#ecf0f1; border-bottom-color:#3498db; }
.dark-theme .overlay-desc .overlay-desc-box div { color:#ccc; }
.node-category-indicator { position:absolute; top:5px; right:5px; width:12px; height:12px; border-radius:50%; border:2px solid white; z-index: 10; pointer-events: none;}
@media(max-width:768px){
  .toolbar { flex-direction:column; align-items:stretch; padding:8px; top:0; max-height: 150px; overflow-y: auto;}
  .toolbar.hide { top: -160px; }
  #mindmap-container { margin-top: 150px; height: calc(100vh - 150px); }
  .sidebar{width:100vw;right:-100vw;top:0; height:100vh; border-radius:0; z-index: 250;} /* Top adjusted when toolbar is fixed */
  .sidebar.open{right:0; top:0; padding-top: 60px;} /* Add padding for close button */
  .sidebar #close-sidebar { position:absolute; top:15px; right:15px;}
  #json-area{width:90vw;height:250px;}
  .minimap { display:none; }
  .shortcut-help { display:none; }
}
</style>
</head>
<body>
<div class="toolbar" id="toolbar">
    <div class="btn-group">
        <button class="btn" id="add-node" title="Aggiungi Nodo (N)"><i class="fas fa-plus"></i> Nodo</button>
        <button class="btn danger" id="remove-node" title="Elimina Nodo (Delete)"><i class="fas fa-minus"></i> Elimina</button>
    </div>
    <div class="divider"></div>
    <div class="btn-group">
        <button class="btn" id="add-connection" title="Connetti Nodi (C)"><i class="fas fa-link"></i> Connetti</button>
        <button class="btn danger" id="remove-connection" title="Elimina Connessione"><i class="fas fa-unlink"></i> Scollega</button>
    </div>
    <div class="divider"></div>
    <div class="btn-group">
        <button class="btn secondary" id="layout-radial" title="Layout Radiale"><i class="fas fa-sun"></i> Radiale</button>
        <button class="btn secondary" id="layout-grid" title="Layout Griglia"><i class="fas fa-th"></i> Griglia</button>
        <button class="btn secondary" id="layout-physics" title="Simulazione Fisica (P)"><i class="fas fa-globe"></i> Fisica</button>
        <button class="btn secondary" id="layout-hierarchy" title="Layout Gerarchico (H)"><i class="fas fa-sitemap"></i> Gerarchia</button>
    </div>
    <div class="divider"></div>
    <div class="btn-group">
        <button class="btn" id="zoom-in" title="Zoom In (+)"><i class="fas fa-search-plus"></i></button>
        <button class="btn" id="zoom-out" title="Zoom Out (-)"><i class="fas fa-search-minus"></i></button>
        <button class="btn" id="fit-screen" title="Adatta Schermo (F)"><i class="fas fa-expand-arrows-alt"></i></button>
    </div>
    <div class="divider"></div>
    <div class="btn-group">
        <button class="btn success" id="save-map" title="Salva Mappa Locale (Ctrl+S)"><i class="fas fa-save"></i> Salva</button>
        <button class="btn" id="open-json-modal" title="Import/Export"><i class="fas fa-code"></i> Import/Export</button>
    </div>
    <div class="divider"></div>
    <div class="btn-group">
        <button class="btn" id="export-png" title="Esporta PNG"><i class="fas fa-image"></i> PNG</button>
        <button class="btn" id="export-pdf" title="Esporta PDF"><i class="fas fa-file-pdf"></i> PDF</button>
    </div>
    <div class="divider"></div>
    <div class="btn-group">
        <button class="btn" id="undo" title="Annulla (Ctrl+Z)"><i class="fas fa-undo"></i></button>
        <button class="btn" id="redo" title="Ripristina (Ctrl+Y)"><i class="fas fa-redo"></i></button>
    </div>
    <div class="divider"></div>
    <div class="btn-group">
        <button class="btn secondary theme-toggle" id="theme-toggle" title="Cambia Tema (T)">
            <span class="theme-toggle-icon"><i class="fas fa-sun"></i><i class="fas fa-moon"></i></span> Tema
        </button>
        <button class="btn secondary" id="open-sidebar" title="Editor Proprietà (E)"><i class="fas fa-edit"></i> Editor</button>
        <button class="btn secondary" id="toggle-toolbar" title="Nascondi/Mostra Toolbar"><i class="fas fa-chevron-up"></i></button>
    </div>
</div>

<div id="mindmap-container">
    <svg id="mindmap-svg" tabindex="0">
        <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" /> <!-- Fill is set by connection color -->
            </marker>
            <marker id="arrowhead-reverse" markerWidth="10" markerHeight="7" refX="1" refY="3.5" orient="auto">
                <polygon points="10 0, 0 3.5, 10 7" /> <!-- Fill is set by connection color -->
            </marker>
            <filter id="glow">
                <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                <feMerge> 
                    <feMergeNode in="coloredBlur"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            </filter>
        </defs>
        <g id="connections-group"></g>
        <g id="nodes-group"></g>
    </svg>
</div>

<div class="sidebar" id="sidebar">
    <button class="btn danger" id="close-sidebar" style="float:right;margin-bottom:15px;"><i class="fas fa-times"></i></button>
    
    <div class="search-container">
        <input type="text" class="search-input" id="node-search" placeholder="Cerca nodi...">
        <i class="fas fa-search search-icon"></i>
    </div>
    
    <div id="node-editor" style="display:none;">
        <h3><i class="fas fa-edit"></i> Modifica Nodo</h3>
        <div class="form-group">
            <label for="node-text">Testo:</label>
            <input type="text" id="node-text" maxlength="50">
        </div>
        <div class="form-group">
            <label for="node-description">Descrizione:</label>
            <textarea id="node-description" rows="3" maxlength="500"></textarea>
        </div>
        <div class="form-group">
            <label for="node-tags">Tag (separati da virgola):</label>
            <input type="text" id="node-tags" placeholder="importante, idea, priorità">
        </div>
        <div class="form-group">
            <label>Categoria:</label>
            <select id="node-category">
                <option value="idea">💡 Idea</option>
                <option value="task">✅ Task</option>
                <option value="person">👤 Persona</option>
                <option value="resource">📚 Risorsa</option>
                <option value="location">📍 Luogo</option>
                <option value="date">📅 Data</option>
                <option value="default">⚪ Default</option>
            </select>
        </div>
        <div class="form-group">
            <label>Colore Nodo:</label>
            <div class="color-picker" id="node-bg-colors"></div>
        </div>
        <div class="form-group">
            <label>Colore Testo:</label>
            <div class="color-picker" id="node-text-colors"></div>
        </div>
        <div class="form-group">
            <label>Icona:</label>
            <div class="icon-picker" id="node-icon-picker"></div>
        </div>
        <div class="form-group">
            <label>Dimensione Nodo:</label>
            <input type="range" id="node-size" min="60" max="200" value="90" step="10">
            <span id="node-size-value">90px</span>
        </div>
        <div class="form-group">
            <label>Dimensione Testo:</label>
            <input type="range" id="node-text-size" min="10" max="24" value="16" step="1">
            <span id="node-text-size-value">16px</span>
        </div>
        <div class="form-group">
             <label>Dimensione Icona:</label>
             <input type="range" id="node-icon-size" min="14" max="54" value="26" step="2">
             <span id="node-icon-size-value">26px</span>
        </div>
        <div class="form-group">
            <label>Forma:</label>
            <select id="node-shape">
                <option value="rect">Rettangolo</option>
                <option value="circle">Cerchio</option>
                <option value="ellipse">Ellisse</option>
                <option value="hex">Esagono</option>
                <option value="diamond">Diamante</option>
            </select>
        </div>
        <div class="form-group">
            <label>Priorità:</label>
            <select id="node-priority">
                <option value="low">🟢 Bassa</option>
                <option value="medium">🟡 Media</option>
                <option value="high">🔴 Alta</option>
            </select>
        </div>
    </div>
    
    <div id="connection-editor" style="display:none;">
        <h3><i class="fas fa-link"></i> Modifica Connessione</h3>
        <div class="form-group">
            <label for="connection-label">Etichetta:</label>
            <input type="text" id="connection-label" maxlength="30">
        </div>
        <div class="form-group">
            <label>Colore:</label>
            <div class="color-picker" id="connection-colors"></div>
        </div>
        <div class="form-group">
            <label for="connection-arrow">Direzione:</label>
            <select id="connection-arrow">
                <option value="forward">→ Avanti</option>
                <option value="backward">← Indietro</option>
                <option value="both">↔ Bidirezionale</option>
                <option value="none">— Nessuna</option>
            </select>
        </div>
        <div class="form-group">
            <label for="connection-style">Stile:</label>
            <select id="connection-style">
                <option value="solid">Linea continua</option>
                <option value="dashed">Linea tratteggiata</option>                
                <option value="dotted">Linea punteggiata</option>
            </select>
        </div>
    </div>
</div>

<div class="minimap" id="minimap">
    <svg id="minimap-svg">
        <g id="minimap-nodes-group"></g>
        <g id="minimap-connections-group"></g>
        <rect class="minimap-viewport" id="minimap-viewport-rect"></rect>
    </svg>
</div>

<div class="shortcut-help" id="shortcut-help">
    <strong>Scorciatoie:</strong><br>
    N - Nuovo nodo<br>
    C - Connetti<br>
    Delete/Backspace - Elimina<br>
    F - Adatta schermo<br>
    E - Editor<br>
    P - Fisica On/Off<br>
    H - Layout Gerarchico<br>
    T - Cambia Tema<br>
    Ctrl+S - Salva Locale<br>
    Ctrl+Z - Annulla<br>
    Ctrl+Y - Ripristina<br>
    +/- = Zoom In/Out
</div>

<div class="loading" id="loading">
    <div class="spinner"></div>
    <span>Elaborazione...</span>
</div>

<div class="toast" id="toast"></div>

<div class="overlay-desc" id="overlay-desc" tabindex="0">
    <div class="overlay-desc-box" id="overlay-desc-box">
        <!-- Content injected by JS -->
    </div>
</div>

<div id="json-modal">
    <div id="json-modal-box">
        <h3><i class="fas fa-code"></i> Import/Export JSON</h3>
        <textarea id="json-area" placeholder="Incolla qui il codice JSON della mappa o modifica quello esistente..."></textarea>
        <div style="margin-top:15px;text-align:right;display:flex;gap:10px;justify-content:flex-end;">
            <button class="btn success" id="btn-export-json"><i class="fas fa-download"></i> Esporta</button>
            <button class="btn" id="btn-import-json"><i class="fas fa-upload"></i> Importa</button>
            <button class="btn secondary" id="btn-close-json"><i class="fas fa-times"></i> Chiudi</button>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script>
// === CONFIGURAZIONE MIGLIORATA ===
const CONFIG = {
    colors: {
        nodes: ["#3498db","#e67e22","#2ecc71","#e74c3c","#9b59b6","#f1c40f","#34495e","#8e44ad","#16a085","#d35400"],
        text: ["#ffffff","#2c3e50","#34495e","#7f8c8d"],
        connections: ["#34495e","#9b59b6","#e67e22","#2ecc71","#e74c3c","#c0392b","#3498db","#f39c12"],
        categories: {
            idea: "#f1c40f", // Giallo
            task: "#2ecc71", // Verde
            person: "#9b59b6", // Viola
            resource: "#3498db", // Blu
            location: "#e74c3c", // Rosso
            date: "#1abc9c", // Turchese
            default: "#bdc3c7" // Grigio
        },
        priority: {
            low: "#27ae60", // Verde
            medium: "#f39c12", // Giallo
            high: "#e74c3c"  // Rosso
        }
    },
    icons: [
        "fas fa-lightbulb","fas fa-star","fas fa-brain","fas fa-book","fas fa-heart",
        "fas fa-users","fas fa-globe","fas fa-comments","fas fa-graduation-cap",
        "fas fa-cube","fas fa-leaf","fas fa-music","fas fa-flask","fas fa-rocket",
        "fas fa-home","fas fa-car","fas fa-phone","fas fa-envelope","fas fa-camera",
        "fas fa-gamepad","fas fa-gift","fas fa-key","fas fa-lock","fas fa-magic",
        "fas fa-flag", "fas fa-cog", "fas fa-briefcase", "fas fa-chart-line"
    ],
    defaultViewBox: "0 0 1200 800",
    localStorageKey: "mindMapAdvancedData",
    shortcuts: {
        'KeyN': () => document.getElementById("add-node").click(),
        'KeyC': () => document.getElementById("add-connection").click(),
        'Delete': () => document.getElementById("remove-node").click(),
        'Backspace': () => document.getElementById("remove-node").click(),
        'KeyF': () => document.getElementById("fit-screen").click(),
        'KeyE': () => document.getElementById("open-sidebar").click(),
        'KeyP': () => document.getElementById("layout-physics").click(),
        'KeyH': () => document.getElementById("layout-hierarchy").click(),
        'KeyT': () => document.getElementById("theme-toggle").click(),
        'Equal': {ctrl:false, action: () => document.getElementById("zoom-in").click()},
        'Minus': {ctrl:false, action: () => document.getElementById("zoom-out").click()},
        'KeyS': {ctrl:true, action: () => document.getElementById("save-map").click()},
        'KeyZ': {ctrl:true, action: () => document.getElementById("undo").click()},
        'KeyY': {ctrl:true, action: () => document.getElementById("redo").click()},
    }
};

const ICON_SVGS = {
  "fas fa-lightbulb": `<svg viewBox="0 0 384 512"><path d="M96 464a16 16 0 0 0 16 16h160a16 16 0 0 0 16-16v-16H96zm96-464C112.9 0 48 64.6 48 144c0 61.9 37.2 114.6 89.7 135.2C149.6 297.8 176 336 176 384v8a24 24 0 0 0 24 24h16a24 24 0 0 0 24-24v-8c0-48 26.4-86.2 56.3-104.8C314.8 258.6 352 205.9 352 144c0-79.4-64.9-144-144-144z"/></svg>`,
  "fas fa-star": `<svg viewBox="0 0 576 512"><path d="M287.9 17.8L354 150.2 490.5 171.5c26.2 3.8 36.7 36 17.7 54.6L402.3 312l23.7 138.4c4.5 26.3-23.2 46-46.4 33.7L288 439.6l-91.6 48.1c-23.2 12.2-50.9-7.4-46.4-33.7L173.7 312 67.8 226.1c-19-18.6-8.5-50.8 17.7-54.6L222 150.2 288.1 17.8c11.7-23.6 45.6-23.9 57.8 0z"/></svg>`,
  "fas fa-brain": `<svg viewBox="0 0 576 512"><path d="M288 0C196.5 0 128 32.7 128 96c0 28.7 16.2 56.5 30.3 76.9C111.8 199.6 64 258.7 64 320c0 79.5 100.5 144 224 144s224-64.5 224-144c0-61.3-47.8-120.4-102.3-147.1C331.8 152.5 348 124.7 348 96c0-63.3-68.5-96-160-96zm160 336c0 17.7-14.3 32-32 32H256c-17.7 0-32-14.3-32-32V272h160v64zm48-160c0 35.3-28.7 64-64 64H224c-35.3 0-64-28.7-64-64s28.7-64 64-64h128c35.3 0 64 28.7 64 64z"/></svg>`,
  "fas fa-book": `<svg viewBox="0 0 448 512"><path d="M448 32H0v448h448V32zM192 416H64V128h128v288zm192 0H256V128h128v288z"/></svg>`,
  "fas fa-users": `<svg viewBox="0 0 640 512"><path d="M192 256c61.9 0 112-50.1 112-112S253.9 32 192 32 80 82.1 80 144s50.1 112 112 112zm76.8 32h-8.3c-20.8 10-43.9 16-68.5 16s-47.6-6-68.5-16h-8.3C51.6 288 0 339.6 0 403.2V432c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48v-28.8c0-63.6-51.6-115.2-115.2-115.2zM480 256c53 0 96-43 96-96s-43-96-96-96-96 43-96 96 43 96 96 96zm48 32h-3.8c-13.9 4.8-28.6 8-44.2 8s-30.3-3.2-44.2-8H432c-20.4 0-38.5 5.9-53.7 15.6C364 325.2 352 349.1 352 374.4V432c0 17.7 14.3 32 32 32h192c17.7 0 32-14.3 32-32v-57.6c0-35.7-20.8-67.3-51.1-82.9-.1-.1-.2-.1-.2-.2z"/></svg>`,
  // Add more SVG paths here for other icons in CONFIG.icons for better export quality
};
function getIconSVG(iconClass, size, color) {
    const svgData = ICON_SVGS[iconClass];
    if (svgData) {
        let svgHtml = svgData.replace(/currentColor/g, color);
        svgHtml = svgHtml.replace(/<svg /, `<svg width="${size}" height="${size}" `);
        return `<div style="width:${size}px;height:${size}px;display:flex;align-items:center;justify-content:center;">${svgHtml}</div>`;
    }
    // Fallback to Font Awesome class if SVG not found (won't export to canvas well)
    return `<div style="width:${size}px;height:${size}px;display:flex;align-items:center;justify-content:center;font-size:${size*0.8}px;color:${color};"><i class="${iconClass}"></i></div>`;
}


// === STATO DELL'APPLICAZIONE ===
let appState = {
    nodes: [],
    connections: [],
    selectedNode: null,
    selectedConnection: null,
    isConnecting: false,
    connectingFrom: null,
    layout: "normal",
    physics: false,
    simulation: null,
    isDarkTheme: false,
    searchTerm: "",
    history: [],
    historyIndex: -1,
    autoSave: true, // Potentially use this for periodic auto-save
    currentViewBox: CONFIG.defaultViewBox.split(" ").map(Number)
};

// === ELEMENTI DOM ===
const svgElem = document.getElementById("mindmap-svg");
const svg = d3.select(svgElem);
const nodesGroup = svg.select("#nodes-group");
const connectionsGroup = svg.select("#connections-group");
const sidebar = document.getElementById("sidebar");
const nodeEditor = document.getElementById("node-editor");
const connEditor = document.getElementById("connection-editor");
const minimapContainer = document.getElementById("minimap");
const minimapSvg = d3.select("#minimap-svg");
const minimapNodesGroup = minimapSvg.select("#minimap-nodes-group");
const minimapConnectionsGroup = minimapSvg.select("#minimap-connections-group");
const minimapViewportRect = minimapSvg.select("#minimap-viewport-rect");
const loadingIndicator = document.getElementById("loading");
const undoButton = document.getElementById("undo");
const redoButton = document.getElementById("redo");


// === UTILITY FUNCTIONS ===
function uniqueId(prefix = "n") {
    return prefix + "_" + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
}

function showToast(message, type = 'success', duration = 3000) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.className = `toast ${type}`; // Ensure previous types are cleared
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), duration);
}

function showLoading(message = "Elaborazione...") {
    loadingIndicator.querySelector("span").textContent = message;
    loadingIndicator.classList.add("show");
}
function hideLoading() {
    loadingIndicator.classList.remove("show");
}

function saveToHistory() {
    const state = {
        nodes: JSON.parse(JSON.stringify(appState.nodes)), // Deep clone
        connections: JSON.parse(JSON.stringify(appState.connections.map(c => ({
            ...c,
            source: c.source.id, // Store only IDs for connections
            target: c.target.id
        })))),
        selectedNodeId: appState.selectedNode ? appState.selectedNode.id : null,
        selectedConnectionId: appState.selectedConnection ? appState.selectedConnection.id : null,
    };
    appState.history = appState.history.slice(0, appState.historyIndex + 1);
    appState.history.push(state);
    appState.historyIndex++;
    if (appState.history.length > 30) { // Limit history size
        appState.history.shift();
        appState.historyIndex--;
    }
    updateUndoRedoButtons();
}

function loadStateFromHistory(state) {
    appState.nodes = [];
    appState.connections = [];
    nodesGroup.selectAll("*").remove();
    connectionsGroup.selectAll("*").remove();

    state.nodes.forEach(nodeData => {
        // Create node without adding to history or redrawing yet
        const nodo = { ...nodeData }; // Create a copy
        appState.nodes.push(nodo);
    });
    
    // Connections need to reference the newly created node objects
    state.connections.forEach(connData => {
        const sourceNode = appState.nodes.find(n => n.id === connData.source);
        const targetNode = appState.nodes.find(n => n.id === connData.target);
        if (sourceNode && targetNode) {
            const conn = { ...connData, source: sourceNode, target: targetNode };
            appState.connections.push(conn);
        }
    });
    
    // Restore selections
    appState.selectedNode = state.selectedNodeId ? appState.nodes.find(n => n.id === state.selectedNodeId) : null;
    appState.selectedConnection = state.selectedConnectionId ? appState.connections.find(c => c.id === state.selectedConnectionId) : null;

    redrawAll();
    if (appState.selectedNode) apriSidebarNodo();
    else if (appState.selectedConnection) apriSidebarConnessione();
    else chiudiSidebar();
    evidenziaSelezione();
    updateUndoRedoButtons();
}

function undo() {
    if (appState.historyIndex > 0) {
        appState.historyIndex--;
        loadStateFromHistory(appState.history[appState.historyIndex]);
        showToast("Annullato", "success", 1500);
    }
}

function redo() {
    if (appState.historyIndex < appState.history.length - 1) {
        appState.historyIndex++;
        loadStateFromHistory(appState.history[appState.historyIndex]);
        showToast("Ripristinato", "success", 1500);
    }
}

function updateUndoRedoButtons() {
    undoButton.disabled = appState.historyIndex <= 0;
    redoButton.disabled = appState.historyIndex >= appState.history.length - 1;
}


// === GESTIONE NODI ===
function creaNodo(x, y, testo = "Nuovo nodo", descr = "", parentId = null) {
    const now = new Date().toISOString();
    const nodo = {
        id: uniqueId("node"),
        x, y,
        text: testo,
        description: descr,
        tags: [],
        category: "default",
        backgroundColor: CONFIG.colors.nodes[Math.floor(Math.random() * CONFIG.colors.nodes.length)],
        textColor: CONFIG.colors.text[0], // Default white
        icon: CONFIG.icons[Math.floor(Math.random() * CONFIG.icons.length)],
        size: 90,
        textSize: 16,
        iconSize: 26, // Default icon size from old code
        shape: "rect",
        priority: "medium",
        parentId,
        createdAt: now,
        updatedAt: now
    };
    
    appState.nodes.push(nodo);
    disegnaNodo(nodo);
    if (appState.autoSave !== false) saveToHistory(); // Allow disabling for batch ops
    updateMinimap();
    return nodo;
}

function rimuoviNodo(nodo) {
    if (!nodo) return;
    
    appState.connections = appState.connections.filter(c => c.source.id !== nodo.id && c.target.id !== nodo.id);
    appState.nodes = appState.nodes.filter(n => n.id !== nodo.id);
    
    d3.select("#" + nodo.id).remove();
    
    if(appState.selectedNode && appState.selectedNode.id === nodo.id) {
        appState.selectedNode = null;
        chiudiSidebar();
    }
    
    aggiornaConnessioni(); // Redraw remaining connections
    saveToHistory();
    updateMinimap();
    showToast("Nodo eliminato", "success");
}

function disegnaNodo(nodo) {
    let g = nodesGroup.select("#" + nodo.id);
    if (!g.empty()) g.remove();
    
    g = nodesGroup.append("g")
        .attr("class", "node")
        .attr("id", nodo.id)
        .attr("transform", `translate(${nodo.x},${nodo.y})`)
        .style("cursor", "pointer")
        .on("dblclick", (event) => {
            event.stopPropagation();
            apriDescrizioneNodo(nodo);
        })
        .on("click", (event) => {
            event.stopPropagation();
            if (appState.isConnecting && appState.connectingFrom && appState.connectingFrom.id !== nodo.id) {
                creaConnessione(appState.connectingFrom, nodo);
                appState.isConnecting = false;
                appState.connectingFrom = null;
                svgElem.style.cursor = "default";
                showToast("Connessione creata!", "success");
            } else {
                selezionaNodo(nodo);
            }
        });

    // Apply dimming if search is active and node doesn't match
    if (appState.searchTerm && !nodoMatchesSearch(nodo, appState.searchTerm)) {
        g.classed("dimmed", true);
    } else {
        g.classed("dimmed", false);
    }
    
    // Drag behavior
    g.call(d3.drag()
        .on("start", function(event) {
            d3.select(this).raise(); // Bring to front
            if (appState.physics && appState.simulation) { 
                nodo.fx = nodo.x; nodo.fy = nodo.y; 
                appState.simulation.alphaTarget(0.2).restart(); 
            }
        })
        .on("drag", function(event) {
            nodo.x = event.x; nodo.y = event.y;
            nodo.updatedAt = new Date().toISOString();
            if (appState.physics && appState.simulation) { 
                nodo.fx = event.x; nodo.fy = event.y; 
            }
            d3.select(this).attr("transform", `translate(${nodo.x},${nodo.y})`);
            aggiornaConnessioni();
            updateMinimap(); // Update minimap during drag
        })
        .on("end", function(event) {
            if (appState.physics && appState.simulation) { 
                nodo.fx = null; nodo.fy = null; 
                appState.simulation.alphaTarget(0); 
            }
            saveToHistory(); // Save state after drag
        })
    );
    
    // SHAPE
    let shapeElement;
    const strokeColor = CONFIG.colors.priority[nodo.priority] || "#2c3e50";
    const strokeWidth = nodo.priority === "high" ? 3 : (nodo.priority === "medium" ? 2 : 1.5);

    if (nodo.shape === "circle") {
        shapeElement = g.append("circle").attr("r", nodo.size / 2);
    } else if (nodo.shape === "ellipse") {
        shapeElement = g.append("ellipse")
            .attr("rx", nodo.size * 0.75 / 2 * 1.2) // Wider ellipse
            .attr("ry", nodo.size / 2);
    } else if (nodo.shape === "hex") {
        let r = nodo.size / 2;
        let h = r * Math.sqrt(3) / 2;
        let points = [[-r,0], [-r/2,-h], [r/2,-h], [r,0], [r/2,h], [-r/2,h]]
            .map(p => [Math.round(p[0]), Math.round(p[1])]).map(p => p.join(",")).join(" ");
        shapeElement = g.append("polygon").attr("points", points);
    } else if (nodo.shape === "diamond") {
        let s = nodo.size / 2;
        let points = [[0, -s], [s*0.8, 0], [0, s], [-s*0.8, 0]] // Adjusted for a more standard diamond
             .map(p => [Math.round(p[0]), Math.round(p[1])]).map(p => p.join(",")).join(" ");
        shapeElement = g.append("polygon").attr("points", points);
    } else { // rect (default)
        shapeElement = g.append("rect")
            .attr("x", -nodo.size * 0.7)
            .attr("y", -nodo.size / 2)
            .attr("rx", 12) // More rounded
            .attr("ry", 12)
            .attr("width", nodo.size * 1.4)
            .attr("height", nodo.size);
    }
    shapeElement.attr("fill", nodo.backgroundColor)
                .attr("stroke", strokeColor)
                .attr("stroke-width", strokeWidth);

    // ICONA
    g.append("foreignObject")
        .attr("x", -nodo.iconSize / 2)
        .attr("y", -nodo.size / 2.2 + (nodo.shape === 'circle' || nodo.shape === 'hex' ? 5 : 0) ) // Adjust Y for icon based on shape
        .attr("width", nodo.iconSize)
        .attr("height", nodo.iconSize + 8) // Extra space for potential descenders
        .style("pointer-events", "none")
        .html(getIconSVG(nodo.icon, nodo.iconSize, nodo.textColor));
    
    // TESTO (max 2 lines, improved wrapping)
    const textYOffset = nodo.iconSize / 1.5 + (nodo.shape === 'circle' || nodo.shape === 'hex' ? 5 : 0); // Adjust Y for text
    const textElement = g.append("text")
        .attr("class", "node-text")
        .attr("font-size", nodo.textSize)
        .attr("text-anchor", "middle")
        .attr("fill", nodo.textColor)
        .style("pointer-events", "none");

    const words = (nodo.text || "").split(/\s+/);
    let line = "";
    let tspan1 = textElement.append("tspan").attr("x", 0).attr("dy", textYOffset);
    let tspan2;
    const maxCharsPerLine = Math.floor((nodo.size * 1.4 * 0.8) / (nodo.textSize * 0.6)); // Approx chars

    for (let word of words) {
        if ((line + word).length > maxCharsPerLine) {
            tspan1.text(line.trim());
            if (!tspan2) {
                tspan2 = textElement.append("tspan").attr("x", 0).attr("dy", `${nodo.textSize + 2}px`);
                line = word + " ";
            } else { // third line or more, truncate
                tspan2.text(tspan2.text() + "..."); // indicate truncation
                line = ""; // stop adding words
                break;
            }
        } else {
            line += word + " ";
        }
    }
    if (line) { // Remaining text
      if (tspan2 && tspan2.text()) tspan2.text(line.trim());
      else tspan1.text(line.trim());
    }
    if(tspan2 && tspan2.text().length === 0) tspan2.remove();


    // CATEGORY INDICATOR (small dot)
    const categoryColor = CONFIG.colors.categories[nodo.category] || CONFIG.colors.categories.default;
    g.append("circle")
        .attr("class", "node-category-indicator-shape")
        .attr("cx", nodo.size * (nodo.shape === 'rect' ? 0.7 : 0.5) - 10) // Position based on shape
        .attr("cy", -nodo.size / 2 + 10)
        .attr("r", 6)
        .attr("fill", categoryColor)
        .attr("stroke", "white")
        .attr("stroke-width", 1.5)
        .style("pointer-events", "none");


    if (appState.selectedNode && appState.selectedNode.id === nodo.id) {
        g.classed("selected", true);
    }
}

function aggiornaNodo(nodo) {
    nodo.updatedAt = new Date().toISOString();
    disegnaNodo(nodo);
    aggiornaConnessioni(); // Connections might need to adjust if node size/shape changes
    updateMinimap();
}

function selezionaNodo(nodo) {
    if (appState.isConnecting) return; // Don't select if in connection mode
    appState.selectedNode = nodo;
    appState.selectedConnection = null;
    evidenziaSelezione();
    apriSidebarNodo();
}


// === GESTIONE CONNESSIONI ===
function creaConnessione(sourceNode, targetNode, label = "") {
    if (!sourceNode || !targetNode || sourceNode.id === targetNode.id) {
      showToast("Impossibile connettere il nodo a se stesso o a un nodo non valido.", "error");
      return null;
    }
    // Check for existing connection (either direction)
    const existing = appState.connections.find(c =>
        (c.source.id === sourceNode.id && c.target.id === targetNode.id) ||
        (c.source.id === targetNode.id && c.target.id === sourceNode.id)
    );
    if (existing) {
        showToast("Connessione già esistente.", "error");
        return existing;
    }

    const conn = {
        id: uniqueId("conn"),
        source: sourceNode,
        target: targetNode,
        label,
        color: CONFIG.colors.connections[Math.floor(Math.random() * CONFIG.colors.connections.length)],
        arrow: "forward",
        style: "solid" // solid, dashed, dotted
    };
    appState.connections.push(conn);
    disegnaConnessione(conn);
    saveToHistory();
    updateMinimap();
    return conn;
}

function rimuoviConnessione(conn) {
    if (!conn) return;
    appState.connections = appState.connections.filter(c => c.id !== conn.id);
    d3.select("#" + conn.id).remove();
    if(appState.selectedConnection && appState.selectedConnection.id === conn.id) {
        appState.selectedConnection = null;
        chiudiSidebar();
    }
    saveToHistory();
    updateMinimap();
    showToast("Connessione eliminata", "success");
}

function disegnaConnessione(conn) {
    if (typeof conn.source === "string") conn.source = appState.nodes.find(n => n.id === conn.source);
    if (typeof conn.target === "string") conn.target = appState.nodes.find(n => n.id === conn.target);
    if (!conn.source || !conn.target) return; // Nodes might have been deleted

    let g = connectionsGroup.select("#" + conn.id);
    if (!g.empty()) g.remove();

    g = connectionsGroup.append("g")
        .attr("class", "connection-group")
        .attr("id", conn.id)
        .style("cursor", "pointer")
        .on("click", event => {
            event.stopPropagation();
            selezionaConnessione(conn);
        });

    const s = conn.source, t = conn.target;
    let sx = s.x, sy = s.y, tx = t.x, ty = t.y;
    
    // Calculate intersection points with node boundaries
    // This is a simplified approach; more accurate calculations depend heavily on exact shape geometry
    const dx = tx - sx, dy = ty - sy;
    const len = Math.sqrt(dx * dx + dy * dy);
    if (len === 0) return; // Avoid division by zero if nodes are at the same spot

    // Approximate radius based on size and shape for arrow positioning
    const getEffectiveRadius = (node) => {
        if (node.shape === 'circle') return node.size / 2;
        if (node.shape === 'ellipse') return Math.min(node.size * 0.75 / 2 * 1.2, node.size / 2); // approx
        if (node.shape === 'hex' || node.shape === 'diamond') return node.size / 2 * 0.8; // approx
        return Math.min(node.size * 0.7, node.size / 2); // For rect
    };

    const r1 = getEffectiveRadius(s);
    const r2 = getEffectiveRadius(t);

    const p1x = sx + dx * r1 / len;
    const p1y = sy + dy * r1 / len;
    const p2x = tx - dx * r2 / len;
    const p2y = ty - dy * r2 / len;
    
    let markerEnd = "", markerStart = "";
    if (conn.arrow === "forward") markerEnd = "url(#arrowhead)";
    if (conn.arrow === "backward") markerStart = "url(#arrowhead-reverse)";
    if (conn.arrow === "both") { markerEnd = "url(#arrowhead)"; markerStart = "url(#arrowhead-reverse)"; }

    const line = g.append("line")
        .attr("class", "connection")
        .attr("x1", p1x).attr("y1", p1y)
        .attr("x2", p2x).attr("y2", p2y)
        .attr("stroke", conn.color)
        .attr("marker-end", markerEnd)
        .attr("marker-start", markerStart);
    
    // Style for dashed/dotted lines
    if (conn.style === "dashed") line.attr("stroke-dasharray", "8,4");
    else if (conn.style === "dotted") line.attr("stroke-dasharray", "2,3");

    // Set fill for arrowheads based on connection color
    svg.selectAll("#arrowhead polygon, #arrowhead-reverse polygon").attr("fill", conn.color);

    if (conn.label) {
        const mx = (p1x + p2x) / 2, my = (p1y + p2y) / 2;
        g.append("text")
            .attr("class", "connection-label")
            .attr("x", mx)
            .attr("y", my - 7)
            .attr("text-anchor", "middle")
            .text(conn.label);
    }
    if (appState.selectedConnection && appState.selectedConnection.id === conn.id) {
        line.classed("selected", true);
    }
}

function aggiornaConnessioni() {
    appState.connections.forEach(disegnaConnessione);
}

function selezionaConnessione(conn) {
    appState.selectedConnection = conn;
    appState.selectedNode = null;
    evidenziaSelezione();
    apriSidebarConnessione();
}

// === SELEZIONE GLOBALE ===
function evidenziaSelezione() {
    nodesGroup.selectAll(".node").classed("selected", false);
    connectionsGroup.selectAll(".connection").classed("selected", false); // Target line directly

    if (appState.selectedNode) {
        nodesGroup.select("#" + appState.selectedNode.id).classed("selected", true);
    }
    if (appState.selectedConnection) {
        const connGroup = connectionsGroup.select("#" + appState.selectedConnection.id);
        if (!connGroup.empty()) {
            connGroup.select(".connection").classed("selected", true);
        }
    }
}

function deselezionaTutto() {
    appState.selectedNode = null;
    appState.selectedConnection = null;
    evidenziaSelezione();
    chiudiSidebar();
}

// === PAN ZOOM SVG (mouse + touch) ===
let isPanning = false, panStart = [0, 0];
function updateViewBox(newViewBox) {
    appState.currentViewBox = newViewBox;
    svgElem.setAttribute("viewBox", newViewBox.join(" "));
    updateMinimapViewport();
}

svgElem.addEventListener("mousedown", function(event) {
    if (event.target === svgElem || event.target.closest("#connections-group") || event.target.closest("#nodes-group")) { // Allow pan on empty space or elements
        if (event.button === 0) { // Left mouse button
            isPanning = true;
            panStart = [event.clientX, event.clientY];
        }
    }
});
svgElem.addEventListener("mousemove", function(event) {
    if (isPanning) {
        const [currentX, currentY, currentW, currentH] = appState.currentViewBox;
        const dx = event.clientX - panStart[0];
        const dy = event.clientY - panStart[1];
        const newX = currentX - dx * (currentW / svgElem.clientWidth);
        const newY = currentY - dy * (currentH / svgElem.clientHeight);
        updateViewBox([newX, newY, currentW, currentH]);
        panStart = [event.clientX, event.clientY]; // Update panStart for continuous panning
    }
});
svgElem.addEventListener("mouseup", function() { if (isPanning) isPanning = false; });
svgElem.addEventListener("mouseleave", function() { if (isPanning) isPanning = false; });

svgElem.addEventListener("wheel", function(event) {
    event.preventDefault();
    let [x, y, w, h] = appState.currentViewBox;
    const zoomFactor = (event.deltaY < 0) ? 0.85 : 1.15; // Smoother zoom
    
    const mouseX = event.offsetX; // Mouse position relative to SVG element
    const mouseY = event.offsetY;

    // Convert mouse position to SVG coordinates
    const svgMouseX = x + mouseX * (w / svgElem.clientWidth);
    const svgMouseY = y + mouseY * (h / svgElem.clientHeight);

    // New width and height
    const newW = w * zoomFactor;
    const newH = h * zoomFactor;

    // Adjust x and y to zoom towards mouse pointer
    const newX = svgMouseX - (mouseX * (newW / svgElem.clientWidth));
    const newY = svgMouseY - (mouseY * (newH / svgElem.clientHeight));
    
    updateViewBox([newX, newY, newW, newH]);
});

// Touch pan/zoom (simplified - 1 finger pan, 2 finger zoom)
let lastTouch1 = null, lastTouch2 = null, initialPinchDistance = null;

svgElem.addEventListener("touchstart", function(event) {
    if (event.target === svgElem || event.target.closest("#connections-group") || event.target.closest("#nodes-group")) {
        if (event.touches.length === 1) {
            isPanning = true;
            lastTouch1 = { x: event.touches[0].clientX, y: event.touches[0].clientY };
        } else if (event.touches.length === 2) {
            isPanning = false; // Stop panning if two fingers are down
            lastTouch1 = { x: event.touches[0].clientX, y: event.touches[0].clientY };
            lastTouch2 = { x: event.touches[1].clientX, y: event.touches[1].clientY };
            initialPinchDistance = Math.hypot(lastTouch1.x - lastTouch2.x, lastTouch1.y - lastTouch2.y);
        }
    }
});

svgElem.addEventListener("touchmove", function(event) {
    event.preventDefault();
    if (isPanning && event.touches.length === 1 && lastTouch1) {
        const [currentX, currentY, currentW, currentH] = appState.currentViewBox;
        const dx = event.touches[0].clientX - lastTouch1.x;
        const dy = event.touches[0].clientY - lastTouch1.y;
        const newX = currentX - dx * (currentW / svgElem.clientWidth);
        const newY = currentY - dy * (currentH / svgElem.clientHeight);
        updateViewBox([newX, newY, currentW, currentH]);
        lastTouch1 = { x: event.touches[0].clientX, y: event.touches[0].clientY };
    } else if (event.touches.length === 2 && lastTouch1 && lastTouch2 && initialPinchDistance) {
        const t1 = { x: event.touches[0].clientX, y: event.touches[0].clientY };
        const t2 = { x: event.touches[1].clientX, y: event.touches[1].clientY };
        const currentPinchDistance = Math.hypot(t1.x - t2.x, t1.y - t2.y);
        const zoomFactor = initialPinchDistance / currentPinchDistance; // Inverse: smaller distance means zoom in
        
        let [x, y, w, h] = appState.currentViewBox;

        // Midpoint of pinch
        const midX = (t1.x + t2.x) / 2;
        const midY = (t1.y + t2.y) / 2;
        
        const svgMidX = x + midX * (w / svgElem.clientWidth);
        const svgMidY = y + midY * (h / svgElem.clientHeight);

        const newW = w * zoomFactor;
        const newH = h * zoomFactor;
        
        const newX = svgMidX - (midX * (newW / svgElem.clientWidth));
        const newY = svgMidY - (midY * (newH / svgElem.clientHeight));

        updateViewBox([newX, newY, newW, newH]);

        initialPinchDistance = currentPinchDistance; // Update for continuous zoom
        lastTouch1 = t1;
        lastTouch2 = t2;
    }
});

svgElem.addEventListener("touchend", function(event) {
    if (event.touches.length < 2) {
        initialPinchDistance = null;
        lastTouch2 = null;
    }
    if (event.touches.length < 1) {
        isPanning = false;
        lastTouch1 = null;
    }
});


// === TOOLBAR ACTIONS ===
document.getElementById("add-node").onclick = () => {
    const [vx, vy, vw, vh] = appState.currentViewBox;
    let x = vx + vw / 2, y = vy + vh / 2; // Center of current view
    let nuovo;
    if (appState.selectedNode) {
        x = appState.selectedNode.x + 120 * (Math.random() - 0.5) * 2; // Spread around selected
        y = appState.selectedNode.y + 100 * (Math.random() - 0.5) * 2;
        nuovo = creaNodo(x, y, "Nuovo Figlio", "", appState.selectedNode.id);
        creaConnessione(appState.selectedNode, nuovo, "");
    } else {
        nuovo = creaNodo(x, y);
    }
    selezionaNodo(nuovo);
};

document.getElementById("remove-node").onclick = () => {
    if (appState.selectedNode) {
        rimuoviNodo(appState.selectedNode);
        // selectedNode is cleared within rimuoviNodo if it was the one removed
    } else {
        showToast("Seleziona un nodo da eliminare.", "error");
    }
};

document.getElementById("add-connection").onclick = () => {
    if (appState.selectedNode) {
        appState.isConnecting = true;
        appState.connectingFrom = appState.selectedNode;
        svgElem.style.cursor = "crosshair";
        showToast("Seleziona il nodo di destinazione...", "success", 5000);
    } else {
        showToast("Seleziona un nodo di partenza per la connessione.", "error");
    }
};

// Click on SVG background to deselect or cancel connection
svgElem.addEventListener("click", function(event) {
    if (event.target === svgElem) { // Click on empty SVG area
        if (appState.isConnecting) {
            appState.isConnecting = false;
            appState.connectingFrom = null;
            svgElem.style.cursor = "default";
            showToast("Creazione connessione annullata.", "error");
        } else {
            deselezionaTutto();
        }
    }
});


document.getElementById("remove-connection").onclick = () => {
    if (appState.selectedConnection) {
        rimuoviConnessione(appState.selectedConnection);
    } else {
        showToast("Seleziona una connessione da eliminare.", "error");
    }
};

document.getElementById("layout-radial").onclick = () => { layoutRadialeMulti(); showToast("Layout Radiale Applicato"); };
document.getElementById("layout-grid").onclick = () => { layoutGriglia(); showToast("Layout Griglia Applicato"); };
document.getElementById("layout-physics").onclick = () => toggleFisica(); // Toast shown in function
document.getElementById("layout-hierarchy").onclick = () => { layoutGerarchico(); showToast("Layout Gerarchico Applicato"); };


document.getElementById("zoom-in").onclick = () => zoomSvg(0.8); // smaller factor for zoom in
document.getElementById("zoom-out").onclick = () => zoomSvg(1.2); // larger factor for zoom out

function zoomSvg(factor) {
    let [x, y, w, h] = appState.currentViewBox;
    const centerX = x + w / 2;
    const centerY = y + h / 2;
    const newW = w * factor;
    const newH = h * factor;
    const newX = centerX - newW / 2;
    const newY = centerY - newH / 2;
    updateViewBox([newX, newY, newW, newH]);
}

document.getElementById("fit-screen").onclick = () => {
    if (appState.nodes.length === 0) {
        updateViewBox(CONFIG.defaultViewBox.split(" ").map(Number));
        return;
    }

    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    appState.nodes.forEach(n => {
        const nodeHalfWidth = (n.shape === 'rect' ? n.size * 0.7 : n.size / 2);
        const nodeHalfHeight = n.size / 2;
        minX = Math.min(minX, n.x - nodeHalfWidth);
        minY = Math.min(minY, n.y - nodeHalfHeight);
        maxX = Math.max(maxX, n.x + nodeHalfWidth);
        maxY = Math.max(maxY, n.y + nodeHalfHeight);
    });

    const padding = 100; // Add some padding around the content
    const contentWidth = maxX - minX + 2 * padding;
    const contentHeight = maxY - minY + 2 * padding;

    if (contentWidth <= 0 || contentHeight <= 0) { // No nodes or single point
        updateViewBox(CONFIG.defaultViewBox.split(" ").map(Number));
        return;
    }
    
    updateViewBox([minX - padding, minY - padding, contentWidth, contentHeight]);
};

document.getElementById("toggle-toolbar").onclick = () => {
    const bar = document.getElementById("toolbar");
    const icon = bar.querySelector("i");
    bar.classList.toggle("hide");
    if (bar.classList.contains("hide")) {
        icon.classList.remove("fa-chevron-up");
        icon.classList.add("fa-chevron-down");
    } else {
        icon.classList.remove("fa-chevron-down");
        icon.classList.add("fa-chevron-up");
    }
};

// === SIDEBAR E FORM ===
document.getElementById("open-sidebar").onclick = () => {
    if (appState.selectedNode) apriSidebarNodo();
    else if (appState.selectedConnection) apriSidebarConnessione();
    else showToast("Seleziona un nodo o una connessione per modificarla.", "error");
};
document.getElementById("close-sidebar").onclick = chiudiSidebar;

function apriSidebarNodo() {
    sidebar.classList.add("open");
    nodeEditor.style.display = "";
    connEditor.style.display = "none";
    aggiornaEditorNodo();
}
function apriSidebarConnessione() {
    sidebar.classList.add("open");
    nodeEditor.style.display = "none";
    connEditor.style.display = "";
    aggiornaEditorConn();
}
function chiudiSidebar() {
    sidebar.classList.remove("open");
}

function aggiornaEditorNodo() {
    const n = appState.selectedNode; if (!n) return;
    document.getElementById("node-text").value = n.text;
    document.getElementById("node-description").value = n.description;
    document.getElementById("node-tags").value = n.tags ? n.tags.join(", ") : "";
    document.getElementById("node-category").value = n.category || "default";
    document.getElementById("node-priority").value = n.priority || "medium";
    document.getElementById("node-size").value = n.size;
    document.getElementById("node-size-value").textContent = n.size + "px";
    document.getElementById("node-text-size").value = n.textSize;
    document.getElementById("node-text-size-value").textContent = n.textSize + "px";
    document.getElementById("node-icon-size").value = n.iconSize || 26;
    document.getElementById("node-icon-size-value").textContent = (n.iconSize || 26) + "px";
    document.getElementById("node-shape").value = n.shape || "rect";
    
    popolaColorPicker("node-bg-colors", CONFIG.colors.nodes, n.backgroundColor, (c) => { n.backgroundColor = c; aggiornaNodo(n); saveToHistory(); });
    popolaColorPicker("node-text-colors", CONFIG.colors.text, n.textColor, (c) => { n.textColor = c; aggiornaNodo(n); saveToHistory(); });
    popolaIconPicker("node-icon-picker", CONFIG.icons, n.icon, (icon) => { n.icon = icon; aggiornaNodo(n); saveToHistory(); });
}

function aggiornaEditorConn() {
    const c = appState.selectedConnection; if (!c) return;
    document.getElementById("connection-label").value = c.label || "";
    document.getElementById("connection-arrow").value = c.arrow || "forward";
    document.getElementById("connection-style").value = c.style || "solid";
    popolaColorPicker("connection-colors", CONFIG.colors.connections, c.color, (col) => { c.color = col; aggiornaConnessioni(); saveToHistory(); });
}

// Generic input handler for sidebar
function handleSidebarInput(elementId, nodeOrConnProperty, isNumeric = false, isArray = false, updateFunc, history = true) {
    document.getElementById(elementId).oninput = e => {
        const targetObject = appState.selectedNode || appState.selectedConnection;
        if (targetObject) {
            let value = e.target.value;
            if (isNumeric) value = Number(value);
            if (isArray) value = value.split(",").map(s => s.trim()).filter(s => s);
            
            targetObject[nodeOrConnProperty] = value;
            targetObject.updatedAt = new Date().toISOString();
            
            updateFunc(targetObject); // e.g., aggiornaNodo or aggiornaConnessioni
            if (history) saveToHistory();

            // For range sliders, update their display value
            const valueDisplayId = elementId + "-value";
            const valueDisplayElem = document.getElementById(valueDisplayId);
            if (valueDisplayElem) valueDisplayElem.textContent = value + "px";
        }
    };
}
// Node editor inputs
handleSidebarInput("node-text", "text", false, false, aggiornaNodo);
handleSidebarInput("node-description", "description", false, false, (n) => {}); // No visual update, just save state
handleSidebarInput("node-tags", "tags", false, true, aggiornaNodo);
handleSidebarInput("node-size", "size", true, false, aggiornaNodo);
handleSidebarInput("node-text-size", "textSize", true, false, aggiornaNodo);
handleSidebarInput("node-icon-size", "iconSize", true, false, aggiornaNodo);

// Special handling for selects as 'oninput' might not be ideal, 'onchange' is better.
document.getElementById("node-category").onchange = e => { if(appState.selectedNode) { appState.selectedNode.category = e.target.value; aggiornaNodo(appState.selectedNode); saveToHistory(); }};
document.getElementById("node-priority").onchange = e => { if(appState.selectedNode) { appState.selectedNode.priority = e.target.value; aggiornaNodo(appState.selectedNode); saveToHistory(); }};
document.getElementById("node-shape").onchange = e => { if(appState.selectedNode) { appState.selectedNode.shape = e.target.value; aggiornaNodo(appState.selectedNode); saveToHistory(); }};

// Connection editor inputs
handleSidebarInput("connection-label", "label", false, false, aggiornaConnessioni);
document.getElementById("connection-arrow").onchange = e => { if(appState.selectedConnection) { appState.selectedConnection.arrow = e.target.value; aggiornaConnessioni(); saveToHistory(); }};
document.getElementById("connection-style").onchange = e => { if(appState.selectedConnection) { appState.selectedConnection.style = e.target.value; aggiornaConnessioni(); saveToHistory(); }};


function popolaColorPicker(containerId, colors, selectedColor, callback) {
    const container = document.getElementById(containerId);
    container.innerHTML = "";
    colors.forEach(color => {
        const option = document.createElement("div");
        option.className = "color-option";
        option.style.background = color;
        if (color === selectedColor) option.classList.add("selected");
        option.onclick = () => {
            callback(color);
            // Update selection state in picker
            Array.from(container.children).forEach(child => child.classList.remove("selected"));
            option.classList.add("selected");
        };
        container.appendChild(option);
    });
}

function popolaIconPicker(containerId, icons, selectedIcon, callback) {
    const container = document.getElementById(containerId);
    container.innerHTML = "";
    icons.forEach(icon => {
        const option = document.createElement("div");
        option.className = "icon-option";
        // Use a neutral color for picker preview, actual color applied in node
        option.innerHTML = getIconSVG(icon, 22, appState.isDarkTheme ? "#ccc" : "#666");
        if (icon === selectedIcon) option.classList.add("selected");
        option.onclick = () => {
            callback(icon);
            Array.from(container.children).forEach(child => child.classList.remove("selected"));
            option.classList.add("selected");
        };
        container.appendChild(option);
    });
}

// === DESCRIZIONE NODO (overlay) ===
function apriDescrizioneNodo(nodo) {
    const overlay = document.getElementById("overlay-desc");
    const box = document.getElementById("overlay-desc-box");
    box.innerHTML = `<h3>${nodo.text || "Nodo"}</h3>
                     <div style="font-size:1.0em;white-space:pre-line;color:${appState.isDarkTheme ? '#ddd' : '#333'};margin-top:10px;">
                         ${nodo.description || "<i>Nessuna descrizione.</i>"}
                     </div>
                     <hr style="border:0; border-top:1px solid ${appState.isDarkTheme ? '#555' : '#ddd'}; margin: 15px 0;">
                     <small style="color:${appState.isDarkTheme ? '#aaa' : '#777'};">
                        Tags: ${nodo.tags && nodo.tags.length > 0 ? nodo.tags.join(', ') : 'N/A'}<br>
                        Categoria: ${nodo.category || 'N/A'}<br>
                        Priorità: ${nodo.priority || 'N/A'}<br>
                        Creato: ${new Date(nodo.createdAt).toLocaleString()}<br>
                        Aggiornato: ${new Date(nodo.updatedAt).toLocaleString()}
                     </small>`;
    overlay.style.display = "flex";
    overlay.focus(); // For Esc key
    
    // No auto-close. User closes with Esc or click.
    // if (nodo.description && window.speechSynthesis) {
    //     const utter = new SpeechSynthesisUtterance(nodo.description);
    //     utter.lang = "it-IT";
    //     window.speechSynthesis.cancel();
    //     window.speechSynthesis.speak(utter);
    // }
}
document.getElementById("overlay-desc").onclick = function(e) { 
    if (e.target === this) { // Only close if background is clicked
        this.style.display = "none"; 
        if (window.speechSynthesis) window.speechSynthesis.cancel();
    }
};
document.getElementById("overlay-desc").onkeydown = function(e) { 
    if (e.key === "Escape") {
        this.style.display = "none"; 
        if (window.speechSynthesis) window.speechSynthesis.cancel();
    }
};


// === EXPORT / IMPORT ===
document.getElementById("export-png").onclick = exportPNG;
document.getElementById("export-pdf").onclick = exportPDF;

function exportPNG() {
    showLoading("Esportazione PNG...");
    // Temporarily ensure all nodes are visible for export
    const currentSearchTerm = appState.searchTerm;
    appState.searchTerm = "";
    redrawAllNodes(); // Redraw without dimming

    html2canvas(document.getElementById("mindmap-container"), { 
        backgroundColor: appState.isDarkTheme ? "#2c3e50" : "#f6f6fa", // Match theme
        useCORS: true,
        logging: false,
        onclone: (doc) => { // Ensure SVGs are properly rendered in the clone
            const svgElements = doc.querySelectorAll('#mindmap-svg svg');
            svgElements.forEach(s => {
                s.setAttribute('width', s.getBBox().width);
                s.setAttribute('height', s.getBBox().height);
            });
        }
    }).then(canvas => {
        canvas.toBlob(blob => {
            downloadFile(blob, "mappa-mentale.png", "image/png");
            hideLoading();
            appState.searchTerm = currentSearchTerm; // Restore search
            redrawAllNodes(); // Redraw with search term
        });
    }).catch(err => {
        console.error("Errore esportazione PNG:", err);
        showToast("Errore esportazione PNG.", "error");
        hideLoading();
        appState.searchTerm = currentSearchTerm; // Restore search
        redrawAllNodes(); // Redraw with search term
    });
}

function exportPDF() {
    showLoading("Esportazione PDF...");
    const currentSearchTerm = appState.searchTerm;
    appState.searchTerm = "";
    redrawAllNodes();

    html2canvas(document.getElementById("mindmap-container"), { 
        backgroundColor: appState.isDarkTheme ? "#2c3e50" : "#f6f6fa",
        useCORS: true,
        logging: false,
         onclone: (doc) => {
            const svgElements = doc.querySelectorAll('#mindmap-svg svg');
            svgElements.forEach(s => {
                s.setAttribute('width', s.getBBox().width);
                s.setAttribute('height', s.getBBox().height);
            });
        }
    }).then(canvas => {
        const imgData = canvas.toDataURL("image/png");
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
            orientation: canvas.width > canvas.height ? "landscape" : "portrait",
            unit: "px",
            format: [canvas.width, canvas.height]
        });
        pdf.addImage(imgData, "PNG", 0, 0, canvas.width, canvas.height);
        pdf.save("mappa-mentale.pdf");
        hideLoading();
        appState.searchTerm = currentSearchTerm;
        redrawAllNodes();
    }).catch(err => {
        console.error("Errore esportazione PDF:", err);
        showToast("Errore esportazione PDF.", "error");
        hideLoading();
        appState.searchTerm = currentSearchTerm;
        redrawAllNodes();
    });
}

document.getElementById("open-json-modal").onclick = () => {
    document.getElementById("json-modal").style.display = "flex";
    document.getElementById("json-area").value = JSON.stringify(salvaMappaFormat(), null, 2);
};
document.getElementById("btn-export-json").onclick = () => {
    const jsonData = JSON.stringify(salvaMappaFormat(), null, 2);
    document.getElementById("json-area").value = jsonData;
    downloadFile(jsonData, "mappa-mentale.json", "application/json");
    showToast("JSON esportato e scaricato!");
};
document.getElementById("btn-import-json").onclick = () => {
    let val = document.getElementById("json-area").value;
    try {
        let data = JSON.parse(val);
        caricaMappa(data);
        showToast("Mappa importata con successo!");
        document.getElementById("json-modal").style.display = "none";
        saveToHistory(); // Initial state for imported map
    } catch (e) {
        console.error("JSON Import Error:", e);
        showToast("Errore: JSON non valido o formato mappa non corretto.", "error");
    }
};
document.getElementById("btn-close-json").onclick = () => {
    document.getElementById("json-modal").style.display = "none";
};

function salvaMappaFormat() {
    return {
        nodes: appState.nodes.map(n => ({ ...n })), // Clone node objects
        connections: appState.connections.map(c => ({
            ...c,
            source: c.source.id, // Store only IDs
            target: c.target.id
        })),
        viewBox: appState.currentViewBox.join(" "),
        theme: appState.isDarkTheme ? 'dark' : 'light'
    };
}

function downloadFile(data, filename, mime) {
    const blob = new Blob([data], { type: mime });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
}

function caricaMappa(data) {
    // Clear existing map
    appState.nodes = [];
    appState.connections = [];
    nodesGroup.selectAll("*").remove();
    connectionsGroup.selectAll("*").remove();
    appState.selectedNode = null;
    appState.selectedConnection = null;
    chiudiSidebar();

    // Load nodes
    data.nodes.forEach(nodeData => {
        const newNode = { ...nodeData }; // Create new object from data
        // Ensure defaults for any missing properties from older formats
        newNode.tags = newNode.tags || [];
        newNode.category = newNode.category || "default";
        newNode.priority = newNode.priority || "medium";
        newNode.iconSize = newNode.iconSize || 26;
        newNode.createdAt = newNode.createdAt || new Date().toISOString();
        newNode.updatedAt = newNode.updatedAt || new Date().toISOString();
        appState.nodes.push(newNode);
    });

    // Load connections (must be done after all nodes are in appState.nodes)
    if (data.connections) {
        data.connections.forEach(connData => {
            const sourceNode = appState.nodes.find(n => n.id === connData.source);
            const targetNode = appState.nodes.find(n => n.id === connData.target);
            if (sourceNode && targetNode) {
                const newConn = { ...connData, source: sourceNode, target: targetNode };
                newConn.style = newConn.style || "solid";
                appState.connections.push(newConn);
            } else {
                console.warn("Impossibile trovare nodi per la connessione:", connData);
            }
        });
    }
    
    if (data.viewBox) {
        updateViewBox(data.viewBox.split(" ").map(Number));
    } else {
        document.getElementById("fit-screen").click(); // Fit to content if no viewBox
    }

    if (data.theme === 'dark' && !appState.isDarkTheme) {
        toggleTheme();
    } else if (data.theme === 'light' && appState.isDarkTheme) {
        toggleTheme();
    }

    redrawAll();
    appState.history = []; // Clear history for new map
    appState.historyIndex = -1;
    saveToHistory(); // Save initial state of loaded map
}

function redrawAll() {
    nodesGroup.selectAll("*").remove();
    connectionsGroup.selectAll("*").remove();
    appState.nodes.forEach(disegnaNodo);
    appState.connections.forEach(disegnaConnessione);
    updateMinimap();
}
function redrawAllNodes() {
    nodesGroup.selectAll("*").remove();
    appState.nodes.forEach(disegnaNodo);
    updateMinimapNodes(); // Only update nodes in minimap
}


// === LOCAL STORAGE ===
document.getElementById("save-map").onclick = () => {
    salvaMappaLocale();
    showToast("Mappa salvata localmente!", "success");
};

function salvaMappaLocale() {
    try {
        const mapData = salvaMappaFormat();
        localStorage.setItem(CONFIG.localStorageKey, JSON.stringify(mapData));
    } catch (e) {
        console.error("Errore salvataggio locale:", e);
        showToast("Errore durante il salvataggio locale. Spazio esaurito?", "error");
    }
}

function caricaMappaLocale() {
    const savedData = localStorage.getItem(CONFIG.localStorageKey);
    if (savedData) {
        try {
            const mapData = JSON.parse(savedData);
            caricaMappa(mapData);
            showToast("Mappa caricata dal salvataggio locale.", "success");
        } catch (e) {
            console.error("Errore caricamento mappa locale:", e);
            showToast("Errore nel caricare la mappa salvata.", "error");
            localStorage.removeItem(CONFIG.localStorageKey); // Remove corrupted data
            initDefaultMap(); // Load default if corrupted
        }
    } else {
        initDefaultMap(); // Load default if no saved data
    }
}

// === LAYOUTS ===
function layoutRadialeMulti() {
    if (appState.nodes.length === 0) return;
    appState.autoSave = false; // Disable history saving for batch updates

    const roots = appState.nodes.filter(n => !n.parentId || !appState.nodes.find(p => p.id === n.parentId));
    const childrenMap = new Map();
    appState.nodes.forEach(n => {
        if (n.parentId) {
            if (!childrenMap.has(n.parentId)) childrenMap.set(n.parentId, []);
            childrenMap.get(n.parentId).push(n);
        }
    });

    const [ centerX, centerY ] = [appState.currentViewBox[0] + appState.currentViewBox[2]/2, appState.currentViewBox[1] + appState.currentViewBox[3]/2];
    
    // Position roots in a circle
    const numRoots = roots.length;
    const rootRadius = numRoots > 1 ? Math.min(appState.currentViewBox[2], appState.currentViewBox[3]) / 4 : 0;
    roots.forEach((root, i) => {
        root.x = centerX + rootRadius * Math.cos(2 * Math.PI * i / numRoots);
        root.y = centerY + rootRadius * Math.sin(2 * Math.PI * i / numRoots);
    });

    function arrangeChildren(parent, level = 1) {
        const children = childrenMap.get(parent.id) || [];
        if (children.length === 0) return;

        const angleStep = (2 * Math.PI) / children.length;
        const maxChildSize = Math.max(...children.map(c => c.size));
        const baseRadius = Math.max(120, parent.size + maxChildSize) + level * 50;
        const spacingRadius = (maxChildSize / Math.sin(angleStep / 2)) * 1.2;
        const radius = Math.max(baseRadius, spacingRadius); // prevent overlap
        let startAngle = -Math.PI / 2; // Start at the top

        // Avoid overlap with parent's parent if possible
        if (parent.parentId) {
            const grandparent = appState.nodes.find(n => n.id === parent.parentId);
            if (grandparent) {
                const angleToGrandparent = Math.atan2(grandparent.y - parent.y, grandparent.x - parent.x);
                startAngle = angleToGrandparent + Math.PI/2 + angleStep/2; // Try to place first child away from grandparent
            }
        }

        children.forEach((child, i) => {
            const angle = startAngle + i * angleStep;
            child.x = parent.x + radius * Math.cos(angle);
            child.y = parent.y + radius * Math.sin(angle);
            arrangeChildren(child, level + 1);
        });
    }

    roots.forEach(root => arrangeChildren(root));
    
    appState.nodes.forEach(n => aggiornaNodo(n)); // This calls redrawAll many times, not ideal
    redrawAll(); // Single redraw after all positions are set
    saveToHistory();
    appState.autoSave = true;
}

function layoutGriglia() {
    if (appState.nodes.length === 0) return;
    appState.autoSave = false;
    const padding = 30;
    const nodeWidthEstimate = 150 + padding; 
    const nodeHeightEstimate = 100 + padding;
    const cols = Math.max(1, Math.floor(appState.currentViewBox[2] / nodeWidthEstimate));
    
    const startX = appState.currentViewBox[0] + nodeWidthEstimate / 2;
    const startY = appState.currentViewBox[1] + nodeHeightEstimate / 2;

    appState.nodes.forEach((node, i) => {
        node.x = startX + (i % cols) * nodeWidthEstimate;
        node.y = startY + Math.floor(i / cols) * nodeHeightEstimate;
    });
    redrawAll();
    saveToHistory();
    appState.autoSave = true;
}

function layoutGerarchico() {
    if (appState.nodes.length === 0) return;
    appState.autoSave = false;

    const roots = appState.nodes.filter(n => !n.parentId || !appState.nodes.find(p => p.id === n.parentId));
    if (roots.length === 0 && appState.nodes.length > 0) { // No explicit roots, pick one
      roots.push(appState.nodes[0]); 
    }
    if (roots.length === 0) {
      showToast("Nessun nodo radice per il layout gerarchico.", "error");
      appState.autoSave = true;
      return;
    }

    // Build a hierarchical structure for D3
    const buildHierarchy = (nodeId) => {
        const node = appState.nodes.find(n => n.id === nodeId);
        if (!node) return null;
        const children = appState.nodes.filter(n => n.parentId === nodeId).map(child => buildHierarchy(child.id));
        return { ...node, children: children.filter(c => c !== null) }; // Pass actual node data
    };
    
    const hierarchicalDataRoots = roots.map(r => buildHierarchy(r.id)).filter(hr => hr);
    if(hierarchicalDataRoots.length === 0) {
        showToast("Errore nella costruzione della gerarchia.", "error");
        appState.autoSave = true;
        return;
    }

    const treeLayout = d3.tree()
        .nodeSize([150, 250]) // [height between levels, width between siblings]
        .separation((a, b) => a.parent === b.parent ? 1.2 : 1.5); // More separation for non-siblings

    let totalMaxY = 0; // Keep track of overall Y to offset multiple trees

    hierarchicalDataRoots.forEach(dataRoot => {
        const rootD3 = d3.hierarchy(dataRoot, d => d.children);
        treeLayout(rootD3);
        
        // Center the tree layout relative to viewport or previous tree
        const nodesD3 = rootD3.descendants();
        if (nodesD3.length === 0) return;

        let minX = Infinity, maxX = -Infinity;
        nodesD3.forEach(d => {
            minX = Math.min(minX, d.x);
            maxX = Math.max(maxX, d.x);
        });
        
        const treeWidth = maxX - minX;
        const offsetX = appState.currentViewBox[0] + appState.currentViewBox[2]/2 - (minX + treeWidth / 2);
        const offsetY = totalMaxY + appState.currentViewBox[1] + 100; // Start below previous tree
        
        let currentTreeMaxY = 0;
        nodesD3.forEach(d => {
            const appNode = appState.nodes.find(n => n.id === d.data.id);
            if (appNode) {
                appNode.x = d.x + offsetX; // d.x is vertical in D3 tree, d.y is horizontal
                appNode.y = d.y + offsetY;
                currentTreeMaxY = Math.max(currentTreeMaxY, appNode.y + appNode.size);
            }
        });
        totalMaxY = currentTreeMaxY + 100; // Add padding for next tree
    });

    redrawAll();
    document.getElementById("fit-screen").click(); // Fit screen after layout
    saveToHistory();
    appState.autoSave = true;
}


function toggleFisica() {
    let btn = document.getElementById("layout-physics");
    if (!appState.physics) {
        appState.physics = true;
        btn.classList.add("active");
        btn.innerHTML = '<i class="fas fa-globe"></i> Fisica (On)';
        
        const links = appState.connections.map(c => ({ source: c.source.id, target: c.target.id, strength: 0.05 + Math.random()*0.1 })); // Add some variability
        
        appState.simulation = d3.forceSimulation(appState.nodes)
            .force("charge", d3.forceManyBody().strength(-500 - Math.random()*200)) // Stronger, varied repulsion
            .force("center", d3.forceCenter(appState.currentViewBox[0] + appState.currentViewBox[2]/2, appState.currentViewBox[1] + appState.currentViewBox[3]/2).strength(0.1))
            .force("collision", d3.forceCollide().radius(d => d.size * 0.8).strength(0.7)) // Adjusted collision
            .force("link", d3.forceLink(links).id(d => d.id).distance(d => (d.source.size + d.target.size) * 0.8 + 50).strength(link => link.strength) )
            .on("tick", () => {
                // Bound nodes to viewport (optional, can be jittery)
                /*
                const [vx, vy, vw, vh] = appState.currentViewBox;
                appState.nodes.forEach(n => {
                    n.x = Math.max(n.size/2 + vx, Math.min(vx + vw - n.size/2, n.x));
                    n.y = Math.max(n.size/2 + vy, Math.min(vy + vh - n.size/2, n.y));
                });
                */
                appState.nodes.forEach(n => disegnaNodo(n)); // More efficient to update transform directly
                aggiornaConnessioni();
                updateMinimap();
            })
            .on("end", () => {
                if (appState.physics) { // Only save if physics is still on (not stopped manually)
                    saveToHistory(); // Save final positions
                }
            });
        showToast("Simulazione Fisica Attivata!", "success");
    } else {
        appState.physics = false;
        btn.classList.remove("active");
        btn.innerHTML = '<i class="fas fa-globe"></i> Fisica';
        if (appState.simulation) {
            appState.simulation.stop();
            appState.simulation = null;
            // Ensure fx and fy are cleared so nodes are not fixed
            appState.nodes.forEach(n => { n.fx = null; n.fy = null; });
            saveToHistory(); // Save current positions after stopping
        }
        showToast("Simulazione Fisica Disattivata.", "success");
    }
}

// === THEME TOGGLE ===
document.getElementById("theme-toggle").onclick = toggleTheme;

function toggleTheme() {
    appState.isDarkTheme = !appState.isDarkTheme;
    document.body.classList.toggle("dark-theme", appState.isDarkTheme);
    localStorage.setItem("mindMapTheme", appState.isDarkTheme ? "dark" : "light");
    
    // Update icon picker icon colors
    if (appState.selectedNode) { // If sidebar is open and showing icons
        popolaIconPicker("node-icon-picker", CONFIG.icons, appState.selectedNode.icon, (icon) => { appState.selectedNode.icon = icon; aggiornaNodo(appState.selectedNode); saveToHistory(); });
    }
    redrawAll(); // Redraw for theme-dependent colors in nodes/connections
    showToast(`Tema ${appState.isDarkTheme ? "Scuro" : "Chiaro"} attivato`, "success");
}

function applySavedTheme() {
    const savedTheme = localStorage.getItem("mindMapTheme");
    if (savedTheme === "dark") {
        appState.isDarkTheme = true;
        document.body.classList.add("dark-theme");
    } else {
        appState.isDarkTheme = false;
        document.body.classList.remove("dark-theme");
    }
}

// === KEYBOARD SHORTCUTS ===
document.addEventListener("keydown", (event) => {
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
        if (event.key === "Escape") event.target.blur(); // Allow Esc to unfocus inputs
        return; // Don't trigger shortcuts if typing in input/textarea
    }
    if (document.getElementById("json-modal").style.display === "flex" && event.key !== "Escape") return; // Only Esc if JSON modal is open
    if (document.getElementById("overlay-desc").style.display === "flex" && event.key !== "Escape") return; // Only Esc if overlay is open
    
    const shortcut = CONFIG.shortcuts[event.code] || CONFIG.shortcuts[event.key]; // event.key for +/-

    if (shortcut) {
        const ctrlNeeded = typeof shortcut.ctrl !== 'undefined' ? shortcut.ctrl : false;
        const action = typeof shortcut.action !== 'undefined' ? shortcut.action : shortcut;

        if (ctrlNeeded && !event.ctrlKey && !event.metaKey) return; // Need Ctrl/Cmd but not pressed
        if (!ctrlNeeded && (event.ctrlKey || event.metaKey)) return; // Don't need Ctrl/Cmd but pressed
        
        event.preventDefault();
        action();
    }
});

// === NODE SEARCH ===
document.getElementById("node-search").addEventListener("input", (e) => {
    appState.searchTerm = e.target.value.toLowerCase();
    redrawAllNodes(); // Redraw nodes to apply dimming
});

function nodoMatchesSearch(nodo, searchTerm) {
    if (!searchTerm) return true;
    return (
        nodo.text.toLowerCase().includes(searchTerm) ||
        nodo.description.toLowerCase().includes(searchTerm) ||
        (nodo.tags && nodo.tags.some(tag => tag.toLowerCase().includes(searchTerm)))
    );
}

// === MINIMAP ===
let minimapScale = 0.1;
const minimapPadding = 5;
let minimapDragging = false;
let minimapDragStart = null;

function updateMinimap() {
    if (!minimapContainer || minimapContainer.offsetParent === null) return; // Hidden

    minimapNodesGroup.selectAll("*").remove();
    minimapConnectionsGroup.selectAll("*").remove();

    if (appState.nodes.length === 0) {
        updateMinimapViewport(); // Still show viewport even if no nodes
        return;
    }

    // Calculate bounds of all nodes to determine minimap scale
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    appState.nodes.forEach(n => {
        const nodeHalfWidth = (n.shape === 'rect' ? n.size * 0.7 : n.size / 2);
        const nodeHalfHeight = n.size / 2;
        minX = Math.min(minX, n.x - nodeHalfWidth);
        minY = Math.min(minY, n.y - nodeHalfHeight);
        maxX = Math.max(maxX, n.x + nodeHalfWidth);
        maxY = Math.max(maxY, n.y + nodeHalfHeight);
    });
    
    const contentWidth = Math.max(1, maxX - minX); // Ensure not zero
    const contentHeight = Math.max(1, maxY - minY);

    const minimapWidth = minimapContainer.clientWidth - 2 * minimapPadding;
    const minimapHeight = minimapContainer.clientHeight - 2 * minimapPadding;

    minimapScale = Math.min(minimapWidth / contentWidth, minimapHeight / contentHeight);
    if (!isFinite(minimapScale) || minimapScale <=0) minimapScale = 0.05; // Fallback scale


    // Center content in minimap
    const scaledContentWidth = contentWidth * minimapScale;
    const scaledContentHeight = contentHeight * minimapScale;
    const translateX = minimapPadding + (minimapWidth - scaledContentWidth) / 2 - minX * minimapScale;
    const translateY = minimapPadding + (minimapHeight - scaledContentHeight) / 2 - minY * minimapScale;
    
    minimapNodesGroup.attr("transform", `translate(${translateX}, ${translateY}) scale(${minimapScale})`);
    minimapConnectionsGroup.attr("transform", `translate(${translateX}, ${translateY}) scale(${minimapScale})`);

    appState.nodes.forEach(n => {
        let shapeMini;
        const miniSize = n.size * 0.8; // Slightly smaller for clarity
        if (n.shape === "circle") {
            shapeMini = minimapNodesGroup.append("circle").attr("cx", n.x).attr("cy", n.y).attr("r", miniSize / 2);
        } else if (n.shape === "ellipse") {
            shapeMini = minimapNodesGroup.append("ellipse").attr("cx", n.x).attr("cy", n.y)
                .attr("rx", miniSize * 0.75 / 2 * 1.2).attr("ry", miniSize / 2);
        } else { // Default to rect for hex, diamond, rect for simplicity
            shapeMini = minimapNodesGroup.append("rect").attr("x", n.x - miniSize * 0.7 / 2).attr("y", n.y - miniSize / 2)
                .attr("width", miniSize * 0.7).attr("height", miniSize);
        }
        shapeMini.attr("fill", n.backgroundColor).attr("class", "node-shape-mini");
        if (appState.selectedNode && n.id === appState.selectedNode.id) {
            shapeMini.attr("stroke", CONFIG.colors.priority.high).attr("stroke-width", 3 / minimapScale); // Thicker border for selected
        }
    });

    appState.connections.forEach(c => {
        if (c.source && c.target) {
            minimapConnectionsGroup.append("line")
                .attr("x1", c.source.x).attr("y1", c.source.y)
                .attr("x2", c.target.x).attr("y2", c.target.y)
                .attr("class", "connection-mini")
                .attr("stroke", c.color);
        }
    });
    updateMinimapViewport();
}

function updateMinimapNodes() { // Lighter update, only for nodes
    minimapNodesGroup.selectAll("*").remove();
     // Calculate bounds of all nodes to determine minimap scale (same as full updateMinimap)
    if (appState.nodes.length === 0) return;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    appState.nodes.forEach(n => {
        const nodeHalfWidth = (n.shape === 'rect' ? n.size * 0.7 : n.size / 2);
        const nodeHalfHeight = n.size / 2;
        minX = Math.min(minX, n.x - nodeHalfWidth);
        minY = Math.min(minY, n.y - nodeHalfHeight);
        maxX = Math.max(maxX, n.x + nodeHalfWidth);
        maxY = Math.max(maxY, n.y + nodeHalfHeight);
    });
    const contentWidth = Math.max(1, maxX - minX);
    const contentHeight = Math.max(1, maxY - minY);
    const minimapWidth = minimapContainer.clientWidth - 2 * minimapPadding;
    const minimapHeight = minimapContainer.clientHeight - 2 * minimapPadding;
    minimapScale = Math.min(minimapWidth / contentWidth, minimapHeight / contentHeight);
    if (!isFinite(minimapScale) || minimapScale <=0) minimapScale = 0.05;
    const scaledContentWidth = contentWidth * minimapScale;
    const scaledContentHeight = contentHeight * minimapScale;
    const translateX = minimapPadding + (minimapWidth - scaledContentWidth) / 2 - minX * minimapScale;
    const translateY = minimapPadding + (minimapHeight - scaledContentHeight) / 2 - minY * minimapScale;
    
    minimapNodesGroup.attr("transform", `translate(${translateX}, ${translateY}) scale(${minimapScale})`);
    // Connections transform remains same unless full updateMinimap is called

    appState.nodes.forEach(n => { // Simplified drawing as in updateMinimap
        let shapeMini;
        const miniSize = n.size * 0.8;
        if (n.shape === "circle") {
            shapeMini = minimapNodesGroup.append("circle").attr("cx", n.x).attr("cy", n.y).attr("r", miniSize / 2);
        } else if (n.shape === "ellipse") {
            shapeMini = minimapNodesGroup.append("ellipse").attr("cx", n.x).attr("cy", n.y)
                .attr("rx", miniSize * 0.75 / 2 * 1.2).attr("ry", miniSize / 2);
        } else {
            shapeMini = minimapNodesGroup.append("rect").attr("x", n.x - miniSize * 0.7 / 2).attr("y", n.y - miniSize / 2)
                .attr("width", miniSize * 0.7).attr("height", miniSize);
        }
        shapeMini.attr("fill", n.backgroundColor).attr("class", "node-shape-mini");
         if (appState.selectedNode && n.id === appState.selectedNode.id) {
            shapeMini.attr("stroke", CONFIG.colors.priority.high).attr("stroke-width", 3 / minimapScale);
        }
    });
    updateMinimapViewport();
}


function updateMinimapViewport() {
    if (!minimapContainer || minimapContainer.offsetParent === null) return; // Hidden
    if (minimapScale <= 0) return; // Not initialized or invalid scale

    const [mainX, mainY, mainW, mainH] = appState.currentViewBox;
    
    // Transform of the content group in minimap
    const transform = d3.zoomTransform(minimapNodesGroup.node()); // Not zoom, but need transform attributes
    const groupTransformMatch = minimapNodesGroup.attr('transform');
    let groupTranslateX = 0, groupTranslateY = 0, groupScale = minimapScale;
    if (groupTransformMatch) {
        const translateMatch = /translate\(([^,]+),([^)]+)\)/.exec(groupTransformMatch);
        const scaleMatch = /scale\(([^)]+)\)/.exec(groupTransformMatch);
        if (translateMatch) {
            groupTranslateX = parseFloat(translateMatch[1]);
            groupTranslateY = parseFloat(translateMatch[2]);
        }
        if (scaleMatch) {
            groupScale = parseFloat(scaleMatch[1]);
        }
    }
    
    minimapViewportRect
        .attr("x", mainX * groupScale + groupTranslateX)
        .attr("y", mainY * groupScale + groupTranslateY)
        .attr("width", mainW * groupScale)
        .attr("height", mainH * groupScale);
}

minimapViewportRect.call(d3.drag()
    .on("start", function(event) {
        minimapDragging = true;
        minimapDragStart = { x: event.x, y: event.y }; // Mouse position relative to viewport rect
    })
    .on("drag", function(event) {
        if (!minimapDragging || minimapScale <= 0) return;
        
        const dx = event.x - minimapDragStart.x;
        const dy = event.y - minimapDragStart.y;

        // Convert minimap drag to main SVG viewbox change
        const mainDx = dx / minimapScale;
        const mainDy = dy / minimapScale;

        let [vx, vy, vw, vh] = appState.currentViewBox;
        updateViewBox([vx + mainDx, vy + mainDy, vw, vh]);
        
        // minimapDragStart is implicitly updated by the viewport moving with the mouse
        // No, we need to update it based on the SVG coordinate system of the minimap
        // For simplicity: the current approach makes the viewport follow the mouse.
        // A better way: calculate start SVG point, then calc new SVG point, then diff.
        // However, since the viewport rect itself is moving, event.x/y are relative to it.
        // The current behavior should be: viewport rect moves, main view changes, then viewport rect redraws.
        // No, `event.x` `event.y` are in the coordinate system of the parent of the dragged element (`minimap-svg`).
        // So, `minimapDragStart` should be updated relative to the new main view.
        // This is complex. Simpler: recalculate what minimapDragStart *would be* for the new main view.
        // Or, just use the delta and don't update minimapDragStart.
        // The issue is the viewport rect is redrawn by updateMinimapViewport.
        // Let's set new main view, then the minimapDragStart will be relative to the *new* position of the rect.
        // Actually, it's simpler: event.dx, event.dy are the change in screen pixels
        const mainScreenDx = event.dx; 
        const mainScreenDy = event.dy;
        
        // We need to scale these screen pixel changes to main SVG coordinate changes
        // This is not what d3.event.dx/dy means.
        // Correct approach:
        // map event.x, event.y to main SVG coordinate for new center of viewport
        // This is done when the drag starts for the initial position.
        // During drag, event.x, event.y are current mouse in minimap parent's coords
        // So, the change (event.x - rect.attr('x')) / minimapScale is the delta for mainX
        // This is too complex for now with the current structure. The basic drag works somewhat.
    })
    .on("end", function() {
        minimapDragging = false;
        minimapDragStart = null;
    })
);
// Also allow click on minimap to center view
minimapSvg.on("click", function(event) {
    if (event.target === minimapSvg.node() || event.target.classList.contains("node-shape-mini") || event.target.classList.contains("connection-mini")) { // Click on minimap background or elements
        if (minimapScale <= 0) return;

        const [mouseX, mouseY] = d3.pointer(event, minimapSvg.node());

        // Transform of the content group in minimap
        const groupTransformMatch = minimapNodesGroup.attr('transform');
        let groupTranslateX = 0, groupTranslateY = 0, groupScale = minimapScale;
         if (groupTransformMatch) {
            const translateMatch = /translate\(([^,]+),([^)]+)\)/.exec(groupTransformMatch);
            const scaleMatch = /scale\(([^)]+)\)/.exec(groupTransformMatch);
            if (translateMatch) {
                groupTranslateX = parseFloat(translateMatch[1]);
                groupTranslateY = parseFloat(translateMatch[2]);
            }
            if (scaleMatch) {
                groupScale = parseFloat(scaleMatch[1]);
            }
        }

        // Convert click in minimap to world coordinates
        const worldX = (mouseX - groupTranslateX) / groupScale;
        const worldY = (mouseY - groupTranslateY) / groupScale;

        // Center main view on this world coordinate
        let [, , vw, vh] = appState.currentViewBox;
        updateViewBox([worldX - vw / 2, worldY - vh / 2, vw, vh]);
    }
});


// === INIT ===
function initDefaultMap(){
    appState.autoSave = false; // Disable history during init
    const [vx, vy, vw, vh] = CONFIG.defaultViewBox.split(" ").map(Number);
    const nodoC = creaNodo(vx + vw/2, vy + vh/2, "Idea Centrale", "Questa è la tua mappa mentale di partenza.");
    const nodoA = creaNodo(nodoC.x + 200, nodoC.y, "Concetto A", "Spiegazione nodo A", nodoC.id);
    const nodoB = creaNodo(nodoC.x, nodoC.y + 150, "Concetto B", "Secondo nodo", nodoC.id);
    const nodoA1 = creaNodo(nodoA.x + 150, nodoA.y - 50, "Dettaglio A1", "", nodoA.id);
    creaConnessione(nodoC, nodoA, "Relazione 1");
    creaConnessione(nodoC, nodoB, "Relazione 2");
    creaConnessione(nodoA, nodoA1, "Approfondisce");
    redrawAll(); // Single redraw after all setup
    appState.autoSave = true;
    saveToHistory(); // Save this initial state
}

(function init() {
    updateViewBox(CONFIG.defaultViewBox.split(" ").map(Number));
    applySavedTheme(); // Apply theme before loading map, as map loading might toggle theme
    caricaMappaLocale(); // This will call initDefaultMap if nothing is saved
    updateMinimap();
    updateUndoRedoButtons();

    // Initial population of icon pickers if sidebar is pre-rendered with a selection
    // This is typically handled when a node is selected and sidebar opens.
    // But if you wanted to pre-populate:
    // if (appState.selectedNode) {
    //     popolaIconPicker("node-icon-picker", CONFIG.icons, appState.selectedNode.icon, () => {});
    // }
    
    // Adjust toolbar visibility based on window size (for mobile)
    const toolbar = document.getElementById("toolbar");
    if (window.innerWidth <= 768 && !toolbar.classList.contains('hide')) {
        // If mobile and toolbar is not explicitly hidden by user, ensure it's visible
        // This might be more complex if 'hide' class is persistent
    } else if (window.innerWidth > 768 && toolbar.classList.contains('hide')) {
        // If desktop and toolbar is hidden (e.g. from previous mobile session), show it
        // This logic might need refinement based on how 'hide' persistence is handled
    }

    // Resize observer for minimap updates
    new ResizeObserver(() => {
        updateMinimap();
        // Also update main SVG viewBox if its aspect ratio needs to be maintained (not typical for this app)
    }).observe(minimapContainer);
    new ResizeObserver(() => {
         let [x,y,w,h] = appState.currentViewBox;
         const newClientWidth = svgElem.clientWidth;
         const newClientHeight = svgElem.clientHeight;
         // If you want to maintain aspect ratio of viewBox based on client rect:
         // w = newClientWidth * (h / oldClientHeight); // Assuming oldClientHeight was stored
         // Or simply redraw minimap viewport which depends on clientWidth/Height
         updateMinimapViewport();
    }).observe(svgElem);


})();
</script>
</body>
</html>
